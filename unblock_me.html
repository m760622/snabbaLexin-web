<!DOCTYPE html>
<html lang="sv" dir="ltr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lås Upp - Unblock Me</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+Arabic:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #5d4037;
            --board-bg: #8d6e63;
            --block-normal: #deb887;
            --block-target: #e53935;
            --block-fixed: #3e2723;
            --border-color: #3e2723;
            --text-color: #efebe9;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --cell-size: 55px;
            --gap: 4px;
            --header-bg: rgba(62, 39, 35, 0.9);
            --header-border: #a1887f;
        }

        /* --- Night Mode Theme --- */
        body.night-mode {
            --bg-color: #0f0c29;
            --board-bg: rgba(255, 255, 255, 0.05);
            --block-normal: #263238;
            --block-target: #ff4081;
            --block-fixed: #000000;
            --border-color: #7b1fa2;
            --text-color: #e1bee7;
            --shadow: 0 0 20px rgba(123, 31, 162, 0.6);
            --header-bg: rgba(15, 12, 41, 0.9);
            --header-border: #7b1fa2;
        }

        body.night-mode {
            background-image:
                radial-gradient(white, rgba(255, 255, 255, .2) 2px, transparent 3px),
                radial-gradient(white, rgba(255, 255, 255, .15) 1px, transparent 2px),
                radial-gradient(white, rgba(255, 255, 255, .1) 2px, transparent 3px),
                linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            background-size: 550px 550px, 350px 350px, 250px 250px, 100% 100%;
            background-position: 0 0, 40px 60px, 130px 270px, 0 0;
        }

        body.night-mode #board {
            background-image: none;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1), inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        body.night-mode .block {
            box-shadow: 0 0 5px #00e5ff, inset 0 0 10px rgba(0, 0, 0, 0.8);
            border: 1px solid #00e5ff;
            background-image: none;
            /* Remove wood grain */
        }

        body.night-mode .block.target {
            box-shadow: 0 0 15px #ff4081, inset 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid #ff4081;
            background-image: none;
        }

        body.night-mode .block.fixed {
            box-shadow: inset 0 0 15px #ff0000;
            border: 1px solid #b71c1c;
            background-image: repeating-linear-gradient(45deg, #000 0, #000 10px, #1a1a1a 10px, #1a1a1a 20px);
        }

        body.night-mode .exit-arrow {
            text-shadow: 0 0 10px #fff, 0 0 20px #00e5ff;
        }

        body.night-mode .btn {
            background: rgba(123, 31, 162, 0.8);
            box-shadow: 0 0 10px #7b1fa2;
            border: 1px solid #e1bee7;
        }

        body.night-mode .btn:active {
            box-shadow: 0 0 5px #7b1fa2;
        }

        body.night-mode .info-bar {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', 'Noto Sans Arabic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%238d6e63' fill-opacity='0.1' fill-rule='evenodd'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/svg%3E");
        }

        /* --- Header --- */
        header {
            width: 100%;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: var(--header-bg);
            backdrop-filter: blur(5px);
            border-bottom: 2px solid var(--header-border);
            box-shadow: var(--shadow);
            position: fixed;
            top: 0;
            z-index: 2001;
            /* Above Start Screen */
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        .icon-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
        }

        /* --- Game Board --- */
        #game-container {
            margin-top: 60px;
            position: relative;
            padding: 10px;
            background: #4e342e;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5), 0 10px 20px rgba(0, 0, 0, 0.4);
            border: 4px solid #3e2723;
        }

        #board {
            width: calc(6 * var(--cell-size) + 7 * var(--gap));
            height: calc(6 * var(--cell-size) + 7 * var(--gap));
            background: var(--board-bg);
            position: relative;
            border-radius: 4px;
            /* Wood grain effect */
            background-image: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.05) 0px, rgba(255, 255, 255, 0.05) 2px, transparent 2px, transparent 10px);
        }

        .block {
            position: absolute;
            background: var(--block-normal);
            border-radius: 4px;
            box-shadow: inset 2px 2px 5px rgba(255, 255, 255, 0.4), inset -2px -2px 5px rgba(0, 0, 0, 0.2), 2px 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .block::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 60%;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 2px;
        }

        .block.target {
            background-color: var(--block-target);
            background-image: repeating-linear-gradient(45deg, rgba(0, 0, 0, 0.1) 0px, rgba(0, 0, 0, 0.1) 2px, transparent 2px, transparent 8px);
        }

        .block.horizontal {
            background-image: repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.05) 0px, rgba(0, 0, 0, 0.05) 1px, transparent 1px, transparent 8px);
        }

        .block.vertical {
            background-image: repeating-linear-gradient(90deg, rgba(0, 0, 0, 0.05) 0px, rgba(0, 0, 0, 0.05) 1px, transparent 1px, transparent 8px);
        }

        .block.fixed {
            background-color: var(--block-fixed);
            cursor: default;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            background-image: radial-gradient(circle at center, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
        }

        .block.fixed::before {
            content: '×';
            color: rgba(255, 255, 255, 0.2);
            font-size: 20px;
        }

        .block:active:not(.fixed) {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .exit-gate {
            position: absolute;
            right: -14px;
            top: calc(2 * var(--cell-size) + 3 * var(--gap));
            width: 14px;
            height: calc(1 * var(--cell-size));
            background: rgba(0, 0, 0, 0.3);
            border-top: 2px solid #3e2723;
            border-bottom: 2px solid #3e2723;
        }

        .exit-arrow {
            position: absolute;
            right: -30px;
            top: calc(2 * var(--cell-size) + 3 * var(--gap) + var(--cell-size)/2 - 10px);
            color: #fff;
            font-size: 20px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        /* --- Info Bar --- */
        .info-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 350px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.8rem;
            color: #bcaaa4;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
        }

        .stars {
            color: #ffd700;
            letter-spacing: 2px;
        }

        /* --- Controls --- */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        .btn {
            background: #6d4c41;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 0 #3e2723;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #3e2723;
        }

        .btn.undo-btn {
            background: #ff9800;
        }

        /* --- Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: #fff;
            color: #333;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 320px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #2e7d32;
        }

        .level-complete-stars {
            font-size: 2rem;
            color: #ffd700;
            margin: 10px 0;
        }

        /* --- Start Screen --- */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(62, 39, 35, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        #start-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .mode-card {
            background: #5d4037;
            border: 2px solid #8d6e63;
            border-radius: 15px;
            padding: 20px;
            margin: 10px;
            width: 280px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .mode-card:hover {
            transform: scale(1.05);
            border-color: #d7ccc8;
        }

        .mode-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .mode-desc {
            color: #bcaaa4;
            font-size: 0.9rem;
        }

        /* --- Ice Mode Visuals --- */
        .block.ice-theme {
            background-color: #b3e5fc !important;
            /* Light Blue */
            border-color: #81d4fa !important;
        }

        .block.ice-theme.target {
            background-color: #e53935 !important;
            /* Keep target red */
        }

        .block.ice-theme::after {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
            opacity: 0.5;
        }

        /* --- Start Screen Night Mode --- */
        body.night-mode #start-screen {
            background: rgba(15, 12, 41, 0.95);
        }

        body.night-mode .mode-card {
            background: rgba(30, 30, 40, 0.6);
            border-color: #7b1fa2;
            box-shadow: 0 0 15px rgba(123, 31, 162, 0.4);
        }

        body.night-mode .mode-card:hover {
            border-color: #00e5ff;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.6);
        }

        body.night-mode .mode-title {
            color: #e1bee7;
            text-shadow: 0 0 5px #7b1fa2;
        }
    </style>
</head>

<body>

    <header>
        <button class="icon-btn" onclick="window.location.href='games.html'" aria-label="Back">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="19" y1="12" x2="5" y2="12"></line>
                <polyline points="12 19 5 12 12 5"></polyline>
            </svg>
        </button>
        <h1>Lås Upp / فك القفل</h1>
        <button class="icon-btn" onclick="game.toggleNightMode()" aria-label="Toggle Night Mode">
            <svg id="theme-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
        </button>
    </header>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 style="font-size: 2.5rem; margin-bottom: 30px; text-shadow: 0 4px 10px rgba(0,0,0,0.5);">Lås Upp</h1>

        <div class="mode-card" onclick="game.startMode('classic')">
            <div class="mode-title">Klassisk / كلاسيكي</div>
            <div class="mode-desc">Flytta blocken fritt<br>حرك الكتل بحرية</div>
        </div>

        <div class="mode-card" onclick="game.startMode('ice')">
            <div class="mode-title">Isblock / جليد</div>
            <div class="mode-desc">Blocken glider till slutet<br>الكتل تنزلق للنهاية</div>
        </div>
    </div>

    <div id="game-container">
        <div id="board">
            <div class="exit-gate"></div>
            <div class="exit-arrow">➜</div>
            <!-- Blocks will be injected here -->
        </div>
    </div>

    <div class="info-bar">
        <div class="info-item">
            <div class="info-label">Nivå / المستوى</div>
            <div class="info-value" id="level-display">1</div>
        </div>
        <div class="info-item">
            <div class="info-label">Drag / حركات</div>
            <div class="info-value" id="moves-display">0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Bästa / الأفضل</div>
            <div class="info-value" id="best-display">-</div>
        </div>
    </div>

    <div class="controls">
        <button class="btn undo-btn" onclick="game.undo()">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 7v6h6" />
                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
            </svg>
            Undo
        </button>
        <button class="btn" onclick="game.resetLevel()">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" />
            </svg>
            Reset
        </button>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">Bra jobbat! / أحسنت!</div>
            <div class="level-complete-stars" id="modal-stars">★★★</div>
            <p>Du klarade nivån på <span id="modal-moves">0</span> drag.</p>
            <p>أكملت المستوى في <span id="modal-moves-ar">0</span> حركة.</p>
            <button class="btn" style="margin: 15px auto 0;" onclick="game.nextLevel()">Nästa / التالي</button>
        </div>
    </div>

    <script>
        // --- Sound Manager ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
            }

            playTone(freq, type, duration, vol = 0.1, slide = 0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slide !== 0) {
                    osc.frequency.exponentialRampToValueAtTime(freq + slide, this.ctx.currentTime + duration);
                }

                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playSlide() {
                // "Pop" sound for movement
                this.playTone(400, 'sine', 0.1, 0.1, 200);
            }

            playHit() {
                // "Bop" sound for collision/fixed block
                this.playTone(150, 'square', 0.1, 0.05, -50);
            }

            playWin() {
                // Arcade Arpeggio
                const now = this.ctx.currentTime;
                [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 'square', 0.1, 0.1), i * 80);
                });
                setTimeout(() => this.playTone(1318.51, 'square', 0.4, 0.1), 480);
            }

            playUndo() {
                // "Rewind" sound
                this.playTone(600, 'sawtooth', 0.15, 0.1, -400);
            }
        }

        // --- Game Logic ---
        class Block {
            constructor(id, x, y, length, orientation, type) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.length = length;
                this.orientation = orientation; // 'h' or 'v'
                this.type = type; // 'target', 'normal', 'fixed'
                this.el = null;
            }
        }

        class UnblockGame {
            constructor() {
                this.board = document.getElementById('board');
                this.cellSize = 55;
                this.gap = 4;
                this.gridSize = 6;
                this.blocks = [];
                this.currentLevel = 0;
                this.moves = 0;
                this.history = []; // For undo
                this.sound = new SoundManager();
                this.gameMode = 'classic'; // 'classic' or 'ice'

                // Persistence
                this.progress = JSON.parse(localStorage.getItem('unblockMe_progress')) || {};

                // Level Data (Same levels for both modes for now)
                // Par: Optimal moves for 3 stars (approximate)
                this.levels = [
                    {
                        par: 10,
                        blocks: [
                            { x: 1, y: 2, len: 2, dir: 'h', type: 'target' },
                            { x: 0, y: 0, len: 3, dir: 'v', type: 'normal' },
                            { x: 1, y: 0, len: 2, dir: 'h', type: 'normal' },
                            { x: 3, y: 0, len: 3, dir: 'v', type: 'normal' },
                            { x: 4, y: 2, len: 2, dir: 'v', type: 'normal' },
                            { x: 0, y: 4, len: 2, dir: 'h', type: 'normal' },
                            { x: 2, y: 4, len: 2, dir: 'v', type: 'normal' },
                            { x: 4, y: 4, len: 2, dir: 'h', type: 'normal' }
                        ]
                    },
                    {
                        par: 15,
                        blocks: [
                            { x: 0, y: 2, len: 2, dir: 'h', type: 'target' },
                            { x: 2, y: 0, len: 3, dir: 'v', type: 'normal' },
                            { x: 3, y: 1, len: 2, dir: 'v', type: 'normal' },
                            { x: 0, y: 4, len: 3, dir: 'h', type: 'normal' },
                            { x: 4, y: 3, len: 2, dir: 'v', type: 'normal' },
                            { x: 2, y: 3, len: 2, dir: 'h', type: 'normal' },
                            { x: 0, y: 0, len: 1, dir: 'h', type: 'fixed' }, // Obstacle
                            { x: 5, y: 5, len: 1, dir: 'h', type: 'fixed' }  // Obstacle
                        ]
                    },
                    {
                        par: 20,
                        blocks: [
                            { x: 1, y: 2, len: 2, dir: 'h', type: 'target' },
                            { x: 0, y: 0, len: 2, dir: 'h', type: 'normal' },
                            { x: 2, y: 0, len: 2, dir: 'h', type: 'normal' },
                            { x: 4, y: 0, len: 2, dir: 'v', type: 'normal' },
                            { x: 0, y: 1, len: 2, dir: 'v', type: 'normal' },
                            { x: 3, y: 1, len: 3, dir: 'v', type: 'normal' },
                            { x: 1, y: 3, len: 2, dir: 'v', type: 'normal' },
                            { x: 0, y: 4, len: 2, dir: 'h', type: 'normal' },
                            { x: 4, y: 4, len: 2, dir: 'v', type: 'normal' },
                            { x: 2, y: 2, len: 1, dir: 'h', type: 'fixed' } // Tricky obstacle
                        ]
                    }
                ];

                // Don't init level yet, wait for mode selection
                this.addEventListeners();

                // Init audio context on first interaction
                window.addEventListener('click', () => {
                    if (this.sound.ctx.state === 'suspended') this.sound.ctx.resume();
                }, { once: true });

                // Load Night Mode Preference
                if (localStorage.getItem('unblockMe_nightMode') === 'true') {
                    this.toggleNightMode(true);
                }
            }

            toggleNightMode(force = null) {
                const body = document.body;
                const isNight = force !== null ? force : !body.classList.contains('night-mode');

                if (isNight) {
                    body.classList.add('night-mode');
                    document.getElementById('theme-icon').innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>'; // Sun icon
                } else {
                    body.classList.remove('night-mode');
                    document.getElementById('theme-icon').innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>'; // Moon icon
                }

                localStorage.setItem('unblockMe_nightMode', isNight);
            }

            startMode(mode) {
                this.gameMode = mode;
                document.getElementById('start-screen').classList.add('hidden');
                this.initLevel(this.currentLevel);
            }

            initLevel(levelIndex) {
                this.currentLevel = levelIndex;
                this.moves = 0;
                this.history = [];
                this.updateUI();

                this.board.innerHTML = '<div class="exit-gate"></div><div class="exit-arrow">➜</div>';
                this.blocks = [];

                const levelData = this.levels[levelIndex % this.levels.length];

                levelData.blocks.forEach((b, i) => {
                    const block = new Block(i, b.x, b.y, b.len, b.dir, b.type);
                    this.createBlockElement(block);
                    this.blocks.push(block);
                });
            }

            updateUI() {
                document.getElementById('level-display').textContent = this.currentLevel + 1;
                document.getElementById('moves-display').textContent = this.moves;

                const key = `${this.gameMode}_${this.currentLevel}`;
                const best = this.progress[key] ? this.progress[key].moves : '-';
                document.getElementById('best-display').textContent = best;
            }

            createBlockElement(block) {
                const el = document.createElement('div');
                let className = `block ${block.type} ${block.orientation === 'h' ? 'horizontal' : 'vertical'}`;
                if (this.gameMode === 'ice') className += ' ice-theme';
                el.className = className;
                el.style.width = block.orientation === 'h'
                    ? `calc(${block.length} * var(--cell-size) + ${block.length - 1} * var(--gap))`
                    : `var(--cell-size)`;
                el.style.height = block.orientation === 'v'
                    ? `calc(${block.length} * var(--cell-size) + ${block.length - 1} * var(--gap))`
                    : `var(--cell-size)`;

                this.updateBlockPosition(el, block.x, block.y);

                el.dataset.id = block.id;
                this.board.appendChild(el);
                block.el = el;
            }

            updateBlockPosition(el, x, y) {
                const left = x * (this.cellSize + this.gap);
                const top = y * (this.cellSize + this.gap);
                el.style.transform = `translate(${left}px, ${top}px)`;
            }

            addEventListeners() {
                const handleStart = (e) => {
                    if (!e.target.classList.contains('block')) return;
                    const id = e.target.dataset.id;
                    const block = this.blocks[id];

                    if (block.type === 'fixed') {
                        this.sound.playHit(); // Feedback that it can't move
                        return;
                    }

                    e.preventDefault();

                    this.isDragging = true;
                    this.draggedBlock = block;

                    const touch = e.touches ? e.touches[0] : e;
                    this.startPos = { x: touch.clientX, y: touch.clientY };
                    this.blockStartPos = { x: this.draggedBlock.x, y: this.draggedBlock.y };
                    this.hasMoved = false;
                };

                const handleMove = (e) => {
                    if (!this.isDragging || !this.draggedBlock) return;
                    e.preventDefault();

                    const touch = e.touches ? e.touches[0] : e;
                    const dx = touch.clientX - this.startPos.x;
                    const dy = touch.clientY - this.startPos.y;

                    // Threshold to start moving
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) this.hasMoved = true;

                    const moveUnits = (this.draggedBlock.orientation === 'h' ? dx : dy) / (this.cellSize + this.gap);

                    // Calculate potential new position
                    let newX = this.blockStartPos.x;
                    let newY = this.blockStartPos.y;

                    if (this.draggedBlock.orientation === 'h') {
                        newX += moveUnits;
                    } else {
                        newY += moveUnits;
                    }

                    // For Ice Mode, we still want to see the drag, but maybe constrain it differently?
                    // Actually, standard drag feels better, then snap to limit on release.
                    const constrained = this.constrainPosition(this.draggedBlock, newX, newY);

                    // Visual Update (smooth)
                    const pixelX = constrained.x * (this.cellSize + this.gap);
                    const pixelY = constrained.y * (this.cellSize + this.gap);
                    this.draggedBlock.el.style.transform = `translate(${pixelX}px, ${pixelY}px)`;

                    // Store temporary visual pos for snap calculation
                    this.draggedBlock.tempX = constrained.x;
                    this.draggedBlock.tempY = constrained.y;
                };

                const handleEnd = () => {
                    if (!this.isDragging || !this.draggedBlock) return;

                    let finalX, finalY;

                    if (this.gameMode === 'ice' && this.hasMoved) {
                        // Calculate slide to limit
                        const limits = this.getLimits(this.draggedBlock);
                        const diffX = this.draggedBlock.tempX - this.blockStartPos.x;
                        const diffY = this.draggedBlock.tempY - this.blockStartPos.y;

                        finalX = this.blockStartPos.x;
                        finalY = this.blockStartPos.y;

                        if (this.draggedBlock.orientation === 'h') {
                            if (diffX > 0.2) finalX = limits.max;
                            else if (diffX < -0.2) finalX = limits.min;
                        } else {
                            if (diffY > 0.2) finalY = limits.max;
                            else if (diffY < -0.2) finalY = limits.min;
                        }
                    } else {
                        // Classic snap
                        finalX = Math.round(this.draggedBlock.tempX);
                        finalY = Math.round(this.draggedBlock.tempY);
                    }

                    // Check if actually moved
                    if (finalX !== this.blockStartPos.x || finalY !== this.blockStartPos.y) {
                        // Save history
                        this.history.push({
                            id: this.draggedBlock.id,
                            x: this.blockStartPos.x,
                            y: this.blockStartPos.y
                        });

                        this.moves++;
                        this.updateUI();
                        this.sound.playSlide();
                    }

                    this.draggedBlock.x = finalX;
                    this.draggedBlock.y = finalY;

                    // Animate to final position
                    this.draggedBlock.el.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    this.updateBlockPosition(this.draggedBlock.el, finalX, finalY);

                    // Reset transition after animation
                    setTimeout(() => {
                        if (this.draggedBlock && this.draggedBlock.el) {
                            this.draggedBlock.el.style.transition = 'transform 0.1s';
                        }
                    }, 200);

                    this.isDragging = false;
                    this.draggedBlock = null;

                    this.checkWin();
                };

                this.board.addEventListener('mousedown', handleStart);
                this.board.addEventListener('touchstart', handleStart, { passive: false });

                window.addEventListener('mousemove', handleMove);
                window.addEventListener('touchmove', handleMove, { passive: false });

                window.addEventListener('mouseup', handleEnd);
                window.addEventListener('touchend', handleEnd);
            }

            getLimits(block) {
                let min = 0;
                let max = this.gridSize - block.length;

                if (block.orientation === 'h') {
                    for (let b of this.blocks) {
                        if (b === block) continue;
                        if (b.y <= block.y && b.y + (b.orientation === 'v' ? b.length : 1) > block.y) {
                            if (b.x + (b.orientation === 'h' ? b.length : 1) <= this.blockStartPos.x) {
                                min = Math.max(min, b.x + (b.orientation === 'h' ? b.length : 1));
                            }
                            if (b.x >= this.blockStartPos.x + block.length) {
                                max = Math.min(max, b.x - block.length);
                            }
                        }
                    }
                    return { min, max };
                } else {
                    for (let b of this.blocks) {
                        if (b === block) continue;
                        if (b.x <= block.x && b.x + (b.orientation === 'h' ? b.length : 1) > block.x) {
                            if (b.y + (b.orientation === 'v' ? b.length : 1) <= this.blockStartPos.y) {
                                min = Math.max(min, b.y + (b.orientation === 'v' ? b.length : 1));
                            }
                            if (b.y >= this.blockStartPos.y + block.length) {
                                max = Math.min(max, b.y - block.length);
                            }
                        }
                    }
                    return { min, max };
                }
            }

            constrainPosition(block, targetX, targetY) {
                const limits = this.getLimits(block);

                if (block.orientation === 'h') {
                    targetX = Math.max(limits.min, Math.min(limits.max, targetX));
                    return { x: targetX, y: block.y };
                } else {
                    targetY = Math.max(limits.min, Math.min(limits.max, targetY));
                    return { x: block.x, y: targetY };
                }
            }

            undo() {
                if (this.history.length === 0) return;

                const lastMove = this.history.pop();
                const block = this.blocks[lastMove.id];

                block.x = lastMove.x;
                block.y = lastMove.y;
                this.updateBlockPosition(block.el, block.x, block.y);

                this.moves--; // Optional: decide if undo reduces move count or not. Usually yes.
                this.updateUI();
                this.sound.playUndo();
            }

            checkWin() {
                const target = this.blocks.find(b => b.type === 'target');
                if (target.x >= 4) {
                    this.sound.playWin();
                    this.saveScore();

                    // Calculate stars
                    const par = this.levels[this.currentLevel % this.levels.length].par;
                    let stars = 1;
                    if (this.moves <= par) stars = 3;
                    else if (this.moves <= par * 1.5) stars = 2;

                    document.getElementById('modal-stars').textContent = '★'.repeat(stars) + '☆'.repeat(3 - stars);
                    document.getElementById('modal-moves').textContent = this.moves;
                    document.getElementById('modal-moves-ar').textContent = this.moves;

                    setTimeout(() => {
                        document.getElementById('win-modal').classList.add('active');
                        this.createConfetti();
                    }, 200);
                }
            }

            saveScore() {
                const key = `${this.gameMode}_${this.currentLevel}`;
                const currentBest = this.progress[key] ? this.progress[key].moves : Infinity;
                if (this.moves < currentBest) {
                    this.progress[key] = { moves: this.moves };
                    localStorage.setItem('unblockMe_progress', JSON.stringify(this.progress));
                }
            }

            nextLevel() {
                document.getElementById('win-modal').classList.remove('active');
                this.initLevel(this.currentLevel + 1);
            }

            resetLevel() {
                this.initLevel(this.currentLevel);
                this.sound.playUndo();
            }

            createConfetti() {
                for (let i = 0; i < 50; i++) {
                    const el = document.createElement('div');
                    el.style.position = 'fixed';
                    el.style.left = Math.random() * 100 + 'vw';
                    el.style.top = '-10px';
                    el.style.width = '10px';
                    el.style.height = '10px';
                    el.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    el.style.zIndex = '2000';
                    el.style.pointerEvents = 'none';
                    document.body.appendChild(el);

                    const anim = el.animate([
                        { transform: `translate(0, 0) rotate(0deg)`, opacity: 1 },
                        { transform: `translate(${Math.random() * 100 - 50}px, 100vh) rotate(${Math.random() * 720}deg)`, opacity: 0 }
                    ], {
                        duration: 1000 + Math.random() * 2000,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    });

                    anim.onfinish = () => el.remove();
                }
            }
        }

        let game;
        window.onload = () => {
            game = new UnblockGame();
        };
    </script>
</body>

</html>